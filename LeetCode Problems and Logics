pattern 
        *
      *    * 
   *     *    *
we are given glasses ith row has i no of glasses and each glass can store 1 cup of wine . else wine will be poured to left and 
right glass . we will be given some quantity of wine and we have to find jth glass of ith row will contain what amount of wine . 
following is the code . 

double champagneTower(int poured, int query_row, int query_glass) {
        vector<double>currRow(1,poured);

        for(int i=0;i<=query_row ; i++)
        {
            vector<double>nextRow(i+2,0);
            for(int j=0;j<=i;j++)
            {
                if(currRow[j] >=1 )
                {
                    nextRow[j] +=(currRow[j]-1)/2.0;
                    nextRow[j+1]+=(currRow[j]-1)/2.0;
                    currRow[j]=1;
                }
            }
            if(i != query_row )
            currRow=nextRow;
        }
        return currRow[query_glass];
    }

* N-Queen Logic 
bool isSafe(int row , int col , vector<string>&board ,  int n)
{
    int r=row;
    int c=col;

    while(r>=0 && c>=0)
    {
        if(board[r][c]=='Q')
        return false;

        r--;
        c--;
    }
    r=row;
    c=col;

    while(c>=0 && r<n)
    {
        if(board[r][c]== 'Q')
        return false;

        r++;
        c--;
    }
    r=row;
    c=col;

    while(c>=0)
    {
        if(board[r][c] == 'Q')
        return false;

        c--;
    }

    return true;
}
void solve(int col ,vector<string>& board , vector<vector<string>> &ans , int n)
{
    if(col == n)
    {
        ans.push_back(board);

        return ;
    }

    for(int row = 0 ; row < n ; row++ )
    {
        if(isSafe(row , col , board , n))
        {
            board[row][col]='Q';
            solve(col+1,board,ans,n);
            board[row][col]='.';
        }
    }
}
    vector<vector<string>> solveNQueens(int n) {
        
        vector<vector<string>>ans;

        vector<string>board(n);

        string s(n,'.');

        for(int i=0;i<n;i++)
        {
            board[i]=s;
        }

        solve(0,board,ans,n);

        return ans;


    }
};

Q. Longest valid paranthisis
int longestValidParentheses(string s) {
        

        int t=0,ans=0;

        stack<int>st;
        st.push(-1);

        for(auto i:s)
        {
            if(i == '(')
            st.push(t);

            else{

                 if( !st.empty() && st.top() != -1 && s[st.top()] == '(')
                {
                    st.pop();
                    ans=max(ans,t-st.top());
                }
                else
                st.push(t);
            }
            t++;

        }
        return ans;

    }
Q Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] 
inclusive can be formed by the sum of some elements in the array.

Return the minimum number of patches required.

 

Example 1:

Input: nums = [1,3], n = 6
Output: 1
 int minPatches(vector<int>& nums, int n) {
        long long sum=0,cnt=0,i=0;

        while(sum < n)
        {
            if(i  < nums.size() && nums[i] <=sum+1)
            sum+=nums[i++];

            else{
                cnt++;
                sum+=sum+1;
            }
        }
        return cnt;
    }


Q. Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.

Return the minimum number of patches required.

int sumOfFlooredPairs(vector<int>& nums) {
	vector<long> freq(2*MAXN+1);        
	long mx = 0, sum = 0;
	for(auto num : nums) ++freq[num], mx = max((int)mx, num);  // counting frequency of each element in nums
	for(int i = 1; i <= 2*MAXN; ++i) freq[i] += freq[i - 1];   // building prefix sum array of freq. Now freq[i] will hold the frequency of numbers less than or equal to i
	// Each num will be assumed in the denominator as floor(nums[i] / num) and 
	// using freq array, we can calculate the number of terms contributing 1, 2, 3... to the sum each.
	for(auto num : nums) { 
		long l = num, r = 2 * num - 1, divResult = 1;
		while(l <= mx) {                
			sum = (sum + divResult * (freq[r] - freq[l - 1])) % MOD;
			l += num, r += num;
			++divResult;
		}
	}
	return sum;
}

ANother Approach :

    int sumOfFlooredPairs(vector<int>& A) {
        long mod = 1e9 + 7, N = A.size(), ans = 0;
        sort(begin(A), end(A));
        for (int i = 0; i < N; ) {
            long j = i + 1;
            while (j < N && A[j] == A[j - 1]) ++j; // skip the duplicates of `A[i]`
            long dup = j - i;
            ans = (ans + dup * dup % mod) % mod; // the `dup` duplicates add `dup * dup` to the answer
            while (j < N) {
                long div = A[j] / A[i], bound = A[i] * (div + 1);
                long next = lower_bound(begin(A) + j, end(A), bound) - begin(A); // find the first number `A[next] >= A[i] * (div + 1)`
                ans = (ans + (next - j) * div % mod * dup % mod) % mod; // Each A[t] (j <= t < next) will add `div * dup` to the answer.
                j = next;
            }
            i += dup;
        }
        return ans;
    }

Q Split Sum Array : make k subarray of the array so that the largest sum will come out to be minimum . 
 private:
    int countPartitions(vector<int>nums , int maxSum)
    {
        int partitions =1; 
        long long subSum=0;

        for(int i=0;i<nums.size();i++)
        {
            if(subSum + nums[i] <= maxSum)
            subSum+=nums[i];

            else{
                partitions++;
                subSum=nums[i];
            }
        }
        return partitions ;
    }
public:

    
    int splitArray(vector<int>& nums, int k) {
        int low=*max_element(nums.begin(),nums.end());

        int high=accumulate(nums.begin(),nums.end(),0);

        while(low <= high){
            int mid=(low+high)/2;
            int partitions=countPartitions(nums,mid);
            if(partitions > k)
            low = mid+1;

            else
            high=mid-1;
        }
        return low;
    }
};
